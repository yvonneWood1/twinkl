'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var util = require('util');

var Events = require('events');

var Timer = require('./timer');

var _require = require('./utils'),
    define = _require.define,
    noop = _require.noop;

var Task =
/*#__PURE__*/
function (_Events) {
  _inherits(Task, _Events);

  function Task() {
    var _this;

    var task = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Task);

    if (typeof task.name !== 'string') {
      throw new TypeError('expected task name to be a string');
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Task).call(this));
    define(_assertThisInitialized(_this), 'isTask', true);
    define(_assertThisInitialized(_this), 'app', task.app);
    _this.name = task.name;
    _this.status = 'pending';
    _this.options = Object.assign({
      deps: []
    }, task.options);
    _this.callback = task.callback || noop;
    _this.deps = [].concat(_toConsumableArray(task.deps || []), _toConsumableArray(_this.options.deps));
    _this.time = new Timer();

    if (_this.setMaxListeners) {
      _this.setMaxListeners(0);
    }

    return _this;
  }

  _createClass(Task, [{
    key: util.inspect.custom,
    value: function value() {
      return "<Task \"".concat(this.name, "\" deps: [").concat(this.deps.join(', '), "]>");
    }
  }, {
    key: "run",
    value: function run(options) {
      var _this2 = this;

      var finished = false;
      var orig = Object.assign({}, this.options);
      this.options = Object.assign({}, this.options, options);
      this.status = 'preparing';
      this.emit('preparing', this);

      if (this.skip(options)) {
        return function () {
          return Promise.resolve(null);
        };
      }

      this.time = new Timer();
      this.time.start();
      this.status = 'starting';
      this.emit('starting', this);
      return function () {
        return new Promise(function _callee(resolve, reject) {
          var finish, res, val;
          return regeneratorRuntime.async(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  finish = function finish(err, value) {
                    if (finished) return;
                    finished = true;

                    try {
                      _this2.options = orig;

                      _this2.time.end();

                      _this2.status = 'finished';

                      _this2.emit('finished', _this2);

                      if (err) {
                        define(err, 'task', _this2);
                        reject(err);

                        _this2.emit('error', err);
                      } else {
                        resolve(value);
                      }
                    } catch (err) {
                      reject(err);
                    }
                  };

                  _context.prev = 1;

                  if (!(typeof _this2.callback !== 'function')) {
                    _context.next = 5;
                    break;
                  }

                  finish();
                  return _context.abrupt("return");

                case 5:
                  res = _this2.callback.call(_this2, finish);

                  if (!(res instanceof Promise)) {
                    _context.next = 11;
                    break;
                  }

                  _context.next = 9;
                  return regeneratorRuntime.awrap(res);

                case 9:
                  val = _context.sent;
                  if (val) res = val;

                case 11:
                  if (!isEmitter(res)) {
                    _context.next = 16;
                    break;
                  }

                  res.on('error', finish);
                  res.on('finish', finish);
                  res.on('end', finish);
                  return _context.abrupt("return");

                case 16:
                  if (_this2.callback.length === 0) {
                    if (res && res.then) {
                      res.then(function () {
                        return finish();
                      });
                    } else {
                      finish(null, res);
                    }
                  }

                  _context.next = 22;
                  break;

                case 19:
                  _context.prev = 19;
                  _context.t0 = _context["catch"](1);
                  finish(_context.t0);

                case 22:
                case "end":
                  return _context.stop();
              }
            }
          }, null, null, [[1, 19]]);
        });
      };
    }
  }, {
    key: "skip",
    value: function skip(options) {
      var app = this.app || {};
      var opts = Object.assign({}, app.options, this.options, options);

      if (opts.run === false) {
        return true;
      }

      if (Array.isArray(opts.skip)) {
        return opts.skip.includes(this.name);
      }

      switch (_typeof(opts.skip)) {
        case 'boolean':
          return opts.skip === true;

        case 'function':
          return opts.skip(this) === true;

        case 'string':
          return opts.skip === this.name;

        default:
          {
            return false;
          }
      }
    }
  }]);

  return Task;
}(Events);

function isEmitter(val) {
  return val && (typeof val.on === 'function' || typeof val.pipe === 'function');
}

module.exports = Task;