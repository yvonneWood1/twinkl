'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var util = require('util');

var Task = require('./task');

var Tasks = require('./tasks');

var parse = require('./parse');

var Events = require('events');

var _require = require('./utils'),
    define = _require.define;
/**
 * Static factory method for creating a custom `Composer` class that
 * extends the given `Emitter`.
 *
 * ```js
 * // Composer extends a basic event emitter by default
 * const Composer = require('composer');
 * const composer = new Composer();
 *
 * // Create a custom Composer class with your even emitter of choice
 * const Emitter = require('some-emitter');
 * const CustomComposer = Composer.create(Emitter);
 * const composer = new CustomComposer();
 * ```
 * @name .create
 * @param {Function} `Emitter` Event emitter.
 * @return {Class} Returns a custom `Composer` class.
 * @api public
 */


var factory = function factory() {
  var Emitter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Events;

  /**
   * Create a new instance of Composer.
   *
   * ```js
   * const composer = new Composer();
   * ```
   * @extends EventEmitter
   * @param {String} `name`
   * @param {Object} `options`
   * @return {Object} Returns an instance of Composer.
   * @api public
   */
  var Generator =
  /*#__PURE__*/
  function (_Tasks$create) {
    _inherits(Generator, _Tasks$create);

    function Generator(name) {
      var _this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Generator);

      if (name && typeof name !== 'string') {
        options = name;
        name = void 0;
      } // ensure that options aren't passed to generic
      // emitter to prevent unintended side-effects


      _this = _possibleConstructorReturn(this, _getPrototypeOf(Generator).call(this, !/(Event)?Emitter/i.test(Emitter.name) ? options : null));
      if (_this.setMaxListeners) _this.setMaxListeners(0);
      _this.name = name;
      _this.options = options;
      _this.namespaces = new Map();
      _this.generators = new Map();
      _this.isGenerate = true;

      if (!_this.use) {
        require('use')(_assertThisInitialized(_this));
      }

      return _this;
    }
    /**
     * Create a wrapped generator function with the given `name`, `config`, and `fn`.
     *
     * @param {String} `name`
     * @param {Object} `config` (optional)
     * @param {Function} `fn`
     * @return {Function}
     * @api public
     */


    _createClass(Generator, [{
      key: "toGenerator",
      value: function toGenerator(name, config, fn) {
        var _this2 = this;

        if (typeof config === 'function' || this.isGenerator(config)) {
          fn = config;
          config = fn || {};
        }

        var alias = this.toAlias(name);

        var generator = function generator(options) {
          if (generator.instance && generator.once !== false) {
            return generator.instance;
          }

          var opts = Object.assign({}, config, options);
          var app = _this2.isGenerator(fn) ? fn : new _this2.constructor(opts);

          _this2.run(app);

          generator.instance = app;
          generator.called++;
          fn.called = generator.called;
          app.createGenerator = generator;
          app.alias = alias;
          app.name = name;
          app.fn = fn;
          define(app, 'parent', _this2);

          _this2.emit('generator', app); // emit errors that happen on initialization


          var listeners = {};

          var bubble = function bubble(events) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = events[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _name = _step.value;

                var listener = listeners[_name] || (listeners[_name] = _this2.emit.bind(_this2, _name));

                app.off(_name, listener);
                app.on(_name, listener);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          };

          bubble(['error', 'task', 'build', 'plugin']);

          if (typeof fn === 'function') {
            fn.call(app, app, opts); // re-register emitters that we just registered a few lines ago,
            // to ensure that errors are bubbled up in the correct order

            bubble(['error', 'task', 'build', 'plugin']);
          }

          if (opts && opts.once === false) {
            generator.once = false;
          }

          return app;
        };

        define(generator, 'name', alias);
        define(generator, 'parent', this);
        define(generator, 'instance', null);
        generator.called = 0;
        generator.isGenerator = true;
        generator.alias = alias;
        generator.fn = fn;
        return generator;
      }
      /**
       * Returns true if the given value is a Composer generator object.
       *
       * @param {Object} `val`
       * @return {Boolean}
       * @api public
       */

    }, {
      key: "isGenerator",
      value: function isGenerator(val) {
        return this.constructor.isGenerator(val);
      }
      /**
       * Alias to `.setGenerator`.
       *
       * ```js
       * app.register('foo', function(app, base) {
       *   // "app" is a private instance created for the generator
       *   // "base" is a shared instance
       * });
       * ```
       * @name .register
       * @param {String} `name` The generator's name
       * @param {Object|Function|String} `options` or generator
       * @param {Object|Function|String} `generator` Generator function, instance or filepath.
       * @return {Object} Returns the generator instance.
       * @api public
       */

    }, {
      key: "register",
      value: function register() {
        return this.setGenerator.apply(this, arguments);
      }
      /**
       * Get and invoke generator `name`, or register generator `name` with
       * the given `val` and `options`, then invoke and return the generator
       * instance. This method differs from `.register`, which lazily invokes
       * generator functions when `.generate` is called.
       *
       * ```js
       * app.generator('foo', function(app, options) {
       *   // "app" - private instance created for generator "foo"
       *   // "options" - options passed to the generator
       * });
       * ```
       * @name .generator
       * @param {String} `name`
       * @param {Function|Object} `fn` Generator function, instance or filepath.
       * @return {Object} Returns the generator instance or undefined if not resolved.
       * @api public
       */

    }, {
      key: "generator",
      value: function generator(name, options, fn) {
        if (typeof options === 'function') {
          fn = options;
          options = {};
        }

        if (typeof fn !== 'function') {
          return this.getGenerator(name, options);
        }

        this.setGenerator(name, options, fn);
        return this.getGenerator(name);
      }
      /**
       * Store a generator by file path or instance with the given
       * `name` and `options`.
       *
       * ```js
       * app.setGenerator('foo', function(app, options) {
       *   // "app" - new instance of Generator created for generator "foo"
       *   // "options" - options passed to the generator
       * });
       * ```
       * @name .setGenerator
       * @param {String} `name` The generator's name
       * @param {Object|Function|String} `options` or generator
       * @param {Object|Function|String} `generator` Generator function, instance or filepath.
       * @return {Object} Returns the generator instance.
       * @api public
       */

    }, {
      key: "setGenerator",
      value: function setGenerator(name, options, fn) {
        var generator = this.toGenerator(name, options, fn);
        var alias = generator.alias;
        this.base.namespaces.set("".concat(this.namespace, ".").concat(alias), generator);
        this.generators.set(alias, generator);
        return this;
      }
      /**
       * Get generator `name` from `app.generators`, same as [findGenerator], but also invokes
       * the returned generator with the current instance. Dot-notation may be used for getting
       * sub-generators.
       *
       * ```js
       * const foo = app.getGenerator('foo');
       *
       * // get a sub-generator
       * const baz = app.getGenerator('foo.bar.baz');
       * ```
       * @name .getGenerator
       * @param {String} `name` Generator name.
       * @return {Object|undefined} Returns the generator instance or undefined.
       * @api public
       */

    }, {
      key: "getGenerator",
      value: function getGenerator(name, options) {
        var fn = this.findGenerator(name);

        if (!this.isGenerator(fn)) {
          throw this.formatError(name);
        }

        if (typeof fn === 'function') {
          // return the generator instance if one has already created,
          // otherwise call the generator function with the parent instance
          return fn.instance || fn.call(fn.parent, options);
        }

        return fn;
      }
      /**
       * Find generator `name`, by first searching the cache, then searching the
       * cache of the `base` generator. Use this to get a generator without invoking it.
       *
       * ```js
       * // search by "alias"
       * const foo = app.findGenerator('foo');
       *
       * // search by "full name"
       * const foo = app.findGenerator('generate-foo');
       * ```
       * @name .findGenerator
       * @param {String} `name`
       * @param {Function} `options` Optionally supply a rename function on `options.toAlias`
       * @return {Object|undefined} Returns the generator instance if found, or undefined.
       * @api public
       */

    }, {
      key: "findGenerator",
      value: function findGenerator(name) {
        var _this3 = this;

        if (!name) return null;
        var cached = this.base.namespaces.get(name);
        var names = [];
        var app = this;

        if (this.isGenerator(cached)) {
          return cached;
        }

        names = typeof name === 'string' ? name.split('.').map(function (n) {
          return _this3.toAlias(n);
        }) : name;
        var key = names.join('.');

        if (names.length === 1) {
          app = this.generators.get(key);
        } else {
          do {
            var alias = names.shift();
            var gen = app.generators.get(alias);

            if (!this.isGenerator(gen)) {
              return null;
            } // only invoke the generator if it's not the last one


            if (names.length) {
              app = gen.instance || app.getGenerator(alias);
            } else {
              app = gen;
            }
          } while (app && names.length);
        }

        return this.isGenerator(app) ? app : null;
      }
      /**
       * Returns true if the given name is a registered generator. Dot-notation may be
       * used to check for sub-generators.
       *
       * ```js
       * console.log(app.hasGenerator('foo'));
       * console.log(app.hasGenerator('foo.bar'));
       * ```
       * @param {String} `name`
       * @return {Boolean}
       * @api public
       */

    }, {
      key: "hasGenerator",
      value: function hasGenerator(name) {
        return this.findGenerator(name) != null;
      }
      /**
       * Run one or more tasks or sub-generators and returns a promise.
       *
       * ```js
       * // run tasks `bar` and `baz` on generator `foo`
       * app.generate('foo', ['bar', 'baz']);
       *
       * // or use shorthand
       * app.generate('foo:bar,baz');
       *
       * // run the `default` task on generator `foo`
       * app.generate('foo');
       *
       * // run the `default` task on the `default` generator, if defined
       * app.generate();
       * ```
       * @name .generate
       * @emits `generate` with the generator `name` and the array of `tasks` that are queued to run.
       * @param {String} `name`
       * @param {String|Array} `tasks`
       * @return {Promise}
       * @api public
       */

    }, {
      key: "generate",
      value: function generate() {
        var _this4 = this;

        var parsed,
            tasks,
            missing,
            options,
            callback,
            promise,
            _args2 = arguments;
        return regeneratorRuntime.async(function generate$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                parsed = this.parseTasks.apply(this, _args2);
                tasks = parsed.tasks, missing = parsed.missing, options = parsed.options, callback = parsed.callback;
                promise = new Promise(function _callee(resolve, reject) {
                  var generator, pending, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, ele, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _ele;

                  return regeneratorRuntime.async(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          if (!(missing.length > 0)) {
                            _context.next = 3;
                            break;
                          }

                          reject(new Error('Invalid task(s) or generator(s): ' + missing.join(', ')));
                          return _context.abrupt("return");

                        case 3:
                          generator = function generator(name) {
                            var app = _this4.hasGenerator(name) ? _this4.getGenerator(name, options) : _this4;

                            _this4.emit('generate', app);

                            return app;
                          };

                          if (!(options.parallel === true)) {
                            _context.next = 28;
                            break;
                          }

                          pending = [];
                          _iteratorNormalCompletion2 = true;
                          _didIteratorError2 = false;
                          _iteratorError2 = undefined;
                          _context.prev = 9;

                          for (_iterator2 = tasks[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            ele = _step2.value;
                            pending.push(generator(ele.name).build(ele.tasks));
                          }

                          _context.next = 17;
                          break;

                        case 13:
                          _context.prev = 13;
                          _context.t0 = _context["catch"](9);
                          _didIteratorError2 = true;
                          _iteratorError2 = _context.t0;

                        case 17:
                          _context.prev = 17;
                          _context.prev = 18;

                          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                            _iterator2["return"]();
                          }

                        case 20:
                          _context.prev = 20;

                          if (!_didIteratorError2) {
                            _context.next = 23;
                            break;
                          }

                          throw _iteratorError2;

                        case 23:
                          return _context.finish(20);

                        case 24:
                          return _context.finish(17);

                        case 25:
                          Promise.all(pending).then(resolve)["catch"](reject);
                          _context.next = 55;
                          break;

                        case 28:
                          _iteratorNormalCompletion3 = true;
                          _didIteratorError3 = false;
                          _iteratorError3 = undefined;
                          _context.prev = 31;
                          _iterator3 = tasks[Symbol.iterator]();

                        case 33:
                          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                            _context.next = 40;
                            break;
                          }

                          _ele = _step3.value;
                          _context.next = 37;
                          return regeneratorRuntime.awrap(generator(_ele.name).build(_ele.tasks)["catch"](reject));

                        case 37:
                          _iteratorNormalCompletion3 = true;
                          _context.next = 33;
                          break;

                        case 40:
                          _context.next = 46;
                          break;

                        case 42:
                          _context.prev = 42;
                          _context.t1 = _context["catch"](31);
                          _didIteratorError3 = true;
                          _iteratorError3 = _context.t1;

                        case 46:
                          _context.prev = 46;
                          _context.prev = 47;

                          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                            _iterator3["return"]();
                          }

                        case 49:
                          _context.prev = 49;

                          if (!_didIteratorError3) {
                            _context.next = 52;
                            break;
                          }

                          throw _iteratorError3;

                        case 52:
                          return _context.finish(49);

                        case 53:
                          return _context.finish(46);

                        case 54:
                          resolve();

                        case 55:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, null, null, [[9, 13, 17, 25], [18,, 20, 24], [31, 42, 46, 54], [47,, 49, 53]]);
                });

                if (!(typeof callback === 'function')) {
                  _context2.next = 6;
                  break;
                }

                promise.then(function () {
                  return callback();
                })["catch"](callback);
                return _context2.abrupt("return");

              case 6:
                return _context2.abrupt("return", promise);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, null, this);
      }
      /**
       * Create a generator alias from the given `name`. By default, `generate-`
       * is stripped from beginning of the generator name.
       *
       * ```js
       * // customize the alias
       * const app = new Generate({ toAlias: require('camel-case') });
       * ```
       * @name .toAlias
       * @param {String} `name`
       * @param {Object} `options`
       * @return {String} Returns the alias.
       * @api public
       */

    }, {
      key: "toAlias",
      value: function toAlias(name, options) {
        if (typeof options === 'function') {
          return options(name);
        }

        if (options && typeof options.toAlias === 'function') {
          return options.toAlias(name);
        }

        if (typeof this.options.toAlias === 'function') {
          return this.options.toAlias(name);
        }

        return name ? name.replace(/^generate-/, '') : '';
      }
      /**
       * Returns true if every name in the given array is a registered generator.
       * @name .isGenerators
       * @param {Array} `names`
       * @return {Boolean}
       * @api public
       */

    }, {
      key: "isGenerators",
      value: function isGenerators(names) {
        var _this5 = this;

        return names.every(function (name) {
          return _this5.hasGenerator(name);
        });
      }
      /**
       * Format task and generator errors.
       * @name .formatError
       * @param {String} `name`
       * @return {Error}
       * @api public
       */

    }, {
      key: "formatError",
      value: function formatError(name) {
        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'generator';
        var appname = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'generator';
        var key = this.namespace || 'default';
        var suffix = '.'; // if not the base instance, remove the first name segment

        if (this !== this.base) {
          key = key.split('.').slice(1).join('.');
          suffix = " on ".concat(appname, " \"").concat(key, "\"");
        }

        var message = "".concat(type, " \"").concat(name, "\" is not registered");
        return new Error(message + suffix);
      }
      /**
       * Disable inspect. Returns a function to re-enable inspect. Useful for debugging.
       * @name .disableInspect
       * @api public
       */

    }, {
      key: "disableInspect",
      value: function disableInspect() {
        var _this6 = this;

        var inspect = this[util.inspect.custom];
        this[util.inspect.custom] = void 0;
        return function () {
          define(_this6, util.inspect.custom, inspect);
        };
      }
      /**
       * Parse task arguments into an array of task configuration objects.
       */

    }, {
      key: "parseTasks",
      value: function parseTasks() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return parse(this.options.register).apply(void 0, [this].concat(args));
      }
      /**
       * Custom inspect function
       */

    }, {
      key: util.inspect.custom,
      value: function value() {
        if (typeof this.options.inspectFn === 'function') {
          return this.options.inspectFn(this);
        }

        var names = this.generators ? _toConsumableArray(this.generators.keys()).join(', ') : '';
        var tasks = this.tasks ? _toConsumableArray(this.tasks.keys()).join(', ') : '';
        return "<Generator \"".concat(this.namespace, "\" tasks: [").concat(tasks, "], generators: [").concat(names, "]>");
      }
      /**
       * Get the first ancestor instance of Composer. Only works if `generator.parent` is
       * defined on child instances.
       * @name .base
       * @getter
       * @api public
       */

    }, {
      key: "base",
      get: function get() {
        return this.parent ? this.parent.base : this;
      }
      /**
       * Get or set the generator name.
       * @name .name
       * @getter
       * @param {String} [name="root"]
       * @return {String}
       * @api public
       */

    }, {
      key: "name",
      set: function set(val) {
        define(this, '_name', val);
      },
      get: function get() {
        return this._name || 'generate';
      }
      /**
       * Get or set the generator `alias`. By default, the generator alias is created
       * by passing the generator name to the [.toAlias](#toAlias) method.
       * @name .alias
       * @getter
       * @param {String} [alias="generate"]
       * @return {String}
       * @api public
       */

    }, {
      key: "alias",
      set: function set(val) {
        define(this, '_alias', val);
      },
      get: function get() {
        return this._alias || this.toAlias(this.name, this.options);
      }
      /**
       * Get the generator namespace. The namespace is created by joining the generator's `alias`
       * to the alias of each ancestor generator.
       * @name .namespace
       * @getter
       * @param {String} [namespace="root"]
       * @return {String}
       * @api public
       */

    }, {
      key: "namespace",
      get: function get() {
        return this.parent ? this.parent.namespace + '.' + this.alias : this.alias;
      }
      /**
       * Get the depth of a generator - useful for debugging. The root generator
       * has a depth of `0`, sub-generators add `1` for each level of nesting.
       * @name .depth
       * @getter
       * @return {Number}
       * @api public
       */

    }, {
      key: "depth",
      get: function get() {
        return this.parent ? this.parent.depth + 1 : 0;
      }
      /**
       * Static method that returns a function for parsing task arguments.
       * @name Composer#parse
       * @param {Function} `register` Function that receives a name of a task or generator that cannot be found by the parse function. This allows the `register` function to dynamically register tasks or generators.
       * @return {Function} Returns a function for parsing task args.
       * @api public
       * @static
       */

    }], [{
      key: "parseTasks",
      value: function parseTasks(register) {
        return parse(register);
      }
      /**
       * Static method that returns true if the given `val` is an instance of Generate.
       * @name Composer#isGenerator
       * @param {Object} `val`
       * @return {Boolean}
       * @api public
       * @static
       */

    }, {
      key: "isGenerator",
      value: function isGenerator(val) {
        return val instanceof this || typeof val === 'function' && val.isGenerator === true;
      }
      /**
       * Static method for creating a custom Composer class with the given `Emitter.
       * @name Composer#create
       * @param {Function} `Emitter`
       * @return {Class} Returns the custom class.
       * @static
       * @api public
       */

    }, {
      key: "create",
      value: function create(Emitter) {
        return factory(Emitter);
      }
      /**
       * Static getter for getting the Tasks class with the same `Emitter` class as Composer.
       * @name Composer#Tasks
       * @param {Function} `Emitter`
       * @return {Class} Returns the Tasks class.
       * @getter
       * @static
       * @api public
       */

    }, {
      key: "Tasks",
      get: function get() {
        return Tasks.create(Emitter);
      }
      /**
       * Static getter for getting the `Task` class.
       *
       * ```js
       * const { Task } = require('composer');
       * ```
       * @name Composer#Task
       * @getter
       * @static
       * @api public
       */

    }, {
      key: "Task",
      get: function get() {
        return Task;
      }
    }]);

    return Generator;
  }(Tasks.create(Emitter));

  return Generator;
};
/**
 * Expose `factory` function
 */


module.exports = factory();