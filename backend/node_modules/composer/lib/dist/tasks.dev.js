'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Task = require('./task');

var Timer = require('./timer');

var Events = require('events');

var _require = require('./utils'),
    createOptions = _require.createOptions,
    flatten = _require.flatten,
    noop = _require.noop;
/**
 * Factory for creating a custom `Tasks` class that extends the
 * given `Emitter`. Or, simply call the factory function to use
 * the built-in emitter.
 *
 * ```js
 * // custom emitter
 * const Emitter = require('events');
 * const Tasks = require('composer/lib/tasks')(Emitter);
 * // built-in emitter
 * const Tasks = require('composer/lib/tasks')();
 * const composer = new Tasks();
 * ```
 * @name .factory
 * @param {function} `Emitter` Event emitter.
 * @return {Class} Returns a custom `Tasks` class.
 * @api public
 */


var factory = function factory() {
  var Emitter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Events;

  /**
   * Create an instance of `Tasks` with the given `options`.
   *
   * ```js
   * const Tasks = require('composer').Tasks;
   * const composer = new Tasks();
   * ```
   * @class
   * @name Tasks
   * @param {object} `options`
   * @api public
   */
  var Tasks =
  /*#__PURE__*/
  function (_Emitter) {
    _inherits(Tasks, _Emitter);

    function Tasks() {
      var _this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Tasks);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Tasks).call(this, !Emitter.name.includes('Emitter') ? options : null));
      _this.options = options;
      _this.taskStack = new Map();
      _this.tasks = new Map();
      _this.taskId = 0;

      if (_this.off === void 0 && typeof _this.removeListener === 'function') {
        _this.off = _this.removeListener.bind(_assertThisInitialized(_this));
      }

      return _this;
    }
    /**
     * Define a task. Tasks run asynchronously, either in series (by default) or parallel
     * (when `options.parallel` is true). In order for the build to determine when a task is
     * complete, _one of the following_ things must happen: 1) the callback must be called, 2) a
     * promise must be returned, or 3) a stream must be returned. Inside tasks, the "this"
     * object is a composer Task instance created for each task with useful properties like
     * the task name, options and timing information, which can be useful for logging, etc.
     *
     * ```js
     * // 1. callback
     * app.task('default', cb => {
     *   // do stuff
     *   cb();
     * });
     * // 2. promise
     * app.task('default', () => {
     *   return Promise.resolve(null);
     * });
     * // 3. stream (using vinyl-fs or your stream of choice)
     * app.task('default', function() {
     *   return vfs.src('foo/*.js');
     * });
     * ```
     * @name .task
     * @param {String} `name` The task name.
     * @param {Object|Array|String|Function} `deps` Any of the following: task dependencies, callback(s), or options object, defined in any order.
     * @param {Function} `callback` (optional) If the last argument is a function, it will be called after all of the task's dependencies have been run.
     * @return {undefined}
     * @api public
     */


    _createClass(Tasks, [{
      key: "task",
      value: function task(name) {
        if (typeof name !== 'string') {
          throw new TypeError('expected task "name" to be a string');
        }

        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }

        var _createOptions = createOptions.apply(void 0, [this, false].concat(rest)),
            options = _createOptions.options,
            tasks = _createOptions.tasks;

        var callback = typeof tasks[tasks.length - 1] === 'function' ? tasks.pop() : noop;
        return this.setTask(name, options, tasks, callback);
      }
      /**
       * Set a task on `app.tasks`
       * @name .setTask
       * @param {string} name Task name
       * @param {object} name Task options
       * @param {object|array|string|function} `deps` Task dependencies
       * @param {Function} `callback` (optional) Final callback function to call after all task dependencies have been run.
       * @return {object} Returns the instance.
       */

    }, {
      key: "setTask",
      value: function setTask(name) {
        var _this2 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var deps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        var callback = arguments.length > 3 ? arguments[3] : undefined;
        var task = new Task({
          name: name,
          options: options,
          deps: deps,
          callback: callback,
          app: this
        });

        var emit = function emit() {
          var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'task';
          return _this2.emit(key, task);
        };

        task.on('error', this.emit.bind(this, 'error'));
        task.on('preparing', function () {
          return emit('task-preparing');
        });
        task.on('starting', function (task) {
          _this2.taskStack.set(task.name, task);

          emit();
        });
        task.on('finished', function (task) {
          _this2.taskStack["delete"](task.name);

          emit();
        });
        this.tasks.set(name, task);
        task.status = 'registered';
        emit('task-registered');
        return this;
      }
      /**
       * Get a task from `app.tasks`.
       * @name .getTask
       * @param {string} name
       * @return {object} Returns the task object.
       */

    }, {
      key: "getTask",
      value: function getTask(name) {
        if (!this.tasks.has(name)) {
          throw this.formatError(name, 'task');
        }

        return this.tasks.get(name);
      }
      /**
       * Returns true if all values in the array are registered tasks.
       * @name .isTasks
       * @param {array} tasks
       * @return {boolean}
       */

    }, {
      key: "isTasks",
      value: function isTasks(arr) {
        var _this3 = this;

        return Array.isArray(arr) && arr.every(function (name) {
          return _this3.tasks.has(name);
        });
      }
      /**
       * Create an array of tasks to run by resolving registered tasks from the values
       * in the given array.
       * @name .expandTasks
       * @param {...[string|function|glob]} tasks
       * @return {array}
       */

    }, {
      key: "expandTasks",
      value: function expandTasks() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var vals = flatten(args).filter(Boolean);

        var keys = _toConsumableArray(this.tasks.keys());

        var tasks = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = vals[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var task = _step.value;

            if (typeof task === 'function') {
              var name = "task-".concat(this.taskId++);
              this.task(name, task);
              tasks.push(name);
              continue;
            }

            if (typeof task === 'string') {
              if (/\*/.test(task)) {
                var matches = match(keys, task);

                if (matches.length === 0) {
                  throw new Error("glob \"".concat(task, "\" does not match any registered tasks"));
                }

                tasks.push.apply(tasks, matches);
                continue;
              }

              tasks.push(task);
              continue;
            }

            var msg = 'expected task dependency to be a string or function, but got: ';
            throw new TypeError(msg + _typeof(task));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return tasks;
      }
      /**
       * Run one or more tasks.
       *
       * ```js
       * const build = app.series(['foo', 'bar', 'baz']);
       * // promise
       * build().then(console.log).catch(console.error);
       * // or callback
       * build(function() {
       *   if (err) return console.error(err);
       * });
       * ```
       * @name .build
       * @param {object|array|string|function} `tasks` One or more tasks to run, options, or callback function. If no tasks are defined, the default task is automatically run.
       * @param {function} `callback` (optional)
       * @return {undefined}
       * @api public
       */

    }, {
      key: "build",
      value: function build() {
        var _this4 = this;

        var _len3,
            args,
            _key3,
            state,
            cb,
            _createOptions2,
            options,
            tasks,
            each,
            build,
            promise,
            _args = arguments;

        return regeneratorRuntime.async(function build$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                for (_len3 = _args.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = _args[_key3];
                }

                state = {
                  status: 'starting',
                  time: new Timer(),
                  app: this
                };
                state.time.start();
                this.emit('build', state);
                args = flatten(args);
                cb = typeof args[args.length - 1] === 'function' ? args.pop() : null;
                _createOptions2 = createOptions.apply(void 0, [this, true].concat(_toConsumableArray(args))), options = _createOptions2.options, tasks = _createOptions2.tasks;
                if (!tasks.length) tasks = ['default'];
                each = options.parallel ? this.parallel : this.series;
                build = each.call.apply(each, [this, options].concat(_toConsumableArray(tasks)));
                promise = build().then(function () {
                  state.time.end();
                  state.status = 'finished';

                  _this4.emit('build', state);
                });
                return _context.abrupt("return", resolveBuild(promise, cb));

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, null, this);
      }
      /**
       * Compose a function to run the given tasks in series.
       *
       * ```js
       * const build = app.series(['foo', 'bar', 'baz']);
       * // promise
       * build().then(console.log).catch(console.error);
       * // or callback
       * build(function() {
       *   if (err) return console.error(err);
       * });
       * ```
       * @name .series
       * @param {object|array|string|function} `tasks` Tasks to run, options, or callback function. If no tasks are defined, the `default` task is automatically run, if one exists.
       * @param {function} `callback` (optional)
       * @return {promise|undefined} Returns a promise if no callback is passed.
       * @api public
       */

    }, {
      key: "series",
      value: function series() {
        var _this5 = this;

        var stack = new Set();
        var compose = this.iterator('series', function _callee(tasks, options, resolve) {
          var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _loop, _iterator2, _step2, _ret;

          return regeneratorRuntime.async(function _callee$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _iteratorNormalCompletion2 = true;
                  _didIteratorError2 = false;
                  _iteratorError2 = undefined;
                  _context3.prev = 3;

                  _loop = function _loop() {
                    var ele, task, run, opts, each, build;
                    return regeneratorRuntime.async(function _loop$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            ele = _step2.value;
                            task = _this5.getTask(ele);
                            task.series = true;

                            if (!(task.skip(options) || stack.has(task))) {
                              _context2.next = 5;
                              break;
                            }

                            return _context2.abrupt("return", "continue");

                          case 5:
                            task.once('finished', function () {
                              return stack["delete"](task);
                            });
                            task.once('starting', function () {
                              return stack.add(task);
                            });
                            run = task.run(options);

                            if (!task.deps.length) {
                              _context2.next = 14;
                              break;
                            }

                            opts = Object.assign({}, options, task.options);
                            each = opts.parallel ? _this5.parallel : _this5.series;
                            build = each.call.apply(each, [_this5].concat(_toConsumableArray(task.deps)));
                            _context2.next = 14;
                            return regeneratorRuntime.awrap(build());

                          case 14:
                            _context2.next = 16;
                            return regeneratorRuntime.awrap(run());

                          case 16:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    });
                  };

                  _iterator2 = tasks[Symbol.iterator]();

                case 6:
                  if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                    _context3.next = 15;
                    break;
                  }

                  _context3.next = 9;
                  return regeneratorRuntime.awrap(_loop());

                case 9:
                  _ret = _context3.sent;

                  if (!(_ret === "continue")) {
                    _context3.next = 12;
                    break;
                  }

                  return _context3.abrupt("continue", 12);

                case 12:
                  _iteratorNormalCompletion2 = true;
                  _context3.next = 6;
                  break;

                case 15:
                  _context3.next = 21;
                  break;

                case 17:
                  _context3.prev = 17;
                  _context3.t0 = _context3["catch"](3);
                  _didIteratorError2 = true;
                  _iteratorError2 = _context3.t0;

                case 21:
                  _context3.prev = 21;
                  _context3.prev = 22;

                  if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                    _iterator2["return"]();
                  }

                case 24:
                  _context3.prev = 24;

                  if (!_didIteratorError2) {
                    _context3.next = 27;
                    break;
                  }

                  throw _iteratorError2;

                case 27:
                  return _context3.finish(24);

                case 28:
                  return _context3.finish(21);

                case 29:
                  resolve();

                case 30:
                case "end":
                  return _context3.stop();
              }
            }
          }, null, null, [[3, 17, 21, 29], [22,, 24, 28]]);
        });
        return compose.apply(void 0, arguments);
      }
      /**
       * Compose a function to run the given tasks in parallel.
       *
       * ```js
       * // call the returned function to start the build
       * const build = app.parallel(['foo', 'bar', 'baz']);
       * // promise
       * build().then(console.log).catch(console.error);
       * // callback
       * build(function() {
       *   if (err) return console.error(err);
       * });
       * // example task usage
       * app.task('default', build);
       * ```
       * @name .parallel
       * @param {object|array|string|function} `tasks` Tasks to run, options, or callback function. If no tasks are defined, the `default` task is automatically run, if one exists.
       * @param {function} `callback` (optional)
       * @return {promise|undefined} Returns a promise if no callback is passed.
       * @api public
       */

    }, {
      key: "parallel",
      value: function parallel() {
        var _this6 = this;

        var stack = new Set();
        var compose = this.iterator('parallel', function (tasks, options, resolve) {
          var pending = [];
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            var _loop2 = function _loop2() {
              var ele = _step3.value;

              var task = _this6.getTask(ele);

              task.parallel = true;

              if (task.skip(options) || stack.has(task)) {
                return "continue";
              }

              task.once('finished', function () {
                return stack["delete"](task);
              });
              task.once('starting', function () {
                return stack.add(task);
              });
              var run = task.run(options);

              if (task.deps.length) {
                var opts = Object.assign({}, options, task.options);
                var each = opts.parallel ? _this6.parallel : _this6.series;
                var build = each.call.apply(each, [_this6].concat(_toConsumableArray(task.deps)));
                pending.push(build().then(function () {
                  return run();
                }));
              } else {
                pending.push(run());
              }
            };

            for (var _iterator3 = tasks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _ret2 = _loop2();

              if (_ret2 === "continue") continue;
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          resolve(Promise.all(pending));
        });
        return compose.apply(void 0, arguments);
      }
      /**
       * Create an async iterator function that ensures that either a promise is
       * returned or the user-provided callback is called.
       * @param {function} `fn` Function to invoke inside the promise.
       * @return {function}
       */

    }, {
      key: "iterator",
      value: function iterator(type, fn) {
        var _this7 = this;

        return function () {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          var _createOptions3 = createOptions.apply(void 0, [_this7, true].concat(args)),
              options = _createOptions3.options,
              tasks = _createOptions3.tasks;

          return function (cb) {
            var promise = new Promise(function _callee2(resolve, reject) {
              var p;
              return regeneratorRuntime.async(function _callee2$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      if (!(tasks.length === 0)) {
                        _context4.next = 3;
                        break;
                      }

                      resolve();
                      return _context4.abrupt("return");

                    case 3:
                      _context4.prev = 3;
                      p = fn(tasks, options, resolve);

                      if (!(type === 'series')) {
                        _context4.next = 8;
                        break;
                      }

                      _context4.next = 8;
                      return regeneratorRuntime.awrap(p);

                    case 8:
                      _context4.next = 13;
                      break;

                    case 10:
                      _context4.prev = 10;
                      _context4.t0 = _context4["catch"](3);
                      reject(_context4.t0);

                    case 13:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, null, null, [[3, 10]]);
            });
            return resolveBuild(promise, cb);
          };
        };
      }
      /**
       * Format task and generator errors.
       * @name .formatError
       * @param {String} `name`
       * @return {Error}
       */

    }, {
      key: "formatError",
      value: function formatError(name) {
        return new Error("task \"".concat(name, "\" is not registered"));
      }
      /**
       * Static method for creating a custom Tasks class with the given `Emitter.
       * @name .create
       * @param {Function} `Emitter`
       * @return {Class} Returns the custom class.
       * @api public
       * @static
       */

    }], [{
      key: "create",
      value: function create(Emitter) {
        return factory(Emitter);
      }
    }]);

    return Tasks;
  }(Emitter);

  return Tasks;
};

function resolveBuild(promise, cb) {
  if (typeof cb === 'function') {
    promise.then(function (val) {
      return cb(null, val);
    })["catch"](cb);
  } else {
    return promise;
  }
}

function match(keys, pattern) {
  var chars = _toConsumableArray(pattern).map(function (ch) {
    return {
      '*': '.*?',
      '.': '\\.'
    }[ch] || ch;
  });

  var regex = new RegExp(chars.join(''));
  return keys.filter(function (key) {
    return regex.test(key);
  });
}

module.exports = factory();